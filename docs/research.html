<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Jiachen Ai | Computational Biology &amp; Human Genetics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Jiachen Ai | Computational Biology &amp; Human Genetics</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./research.html" aria-current="page"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./projects.html"> 
<span class="menu-text">Code</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jiachen-ai-966132264/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jacenai"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:jiachenai@ucla.edu"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">







  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Research ‚Äî Jiachen Ai</title>
  <meta name="description" content="Research interests and work on statistical methods for context-specific eQTLs by Jiachen Ai.">

  <style>
    /* =====================================================
       THEME TOKENS
       ===================================================== */
    :root {
      --ink: #1f2430;
      --muted: #5f6673;
      --line: #e8edf4;
      --bg: #fbfbfd;
      --card: #ffffff;
      --accent: #6f42c1;
      --accent-2: #efe7ff;
      --radius: 16px;
      --shadow: 0 10px 28px rgba(23, 24, 31, 0.08);
      --maxw: 980px;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --ink: #e7eaf2;
        --muted: #a6aec1;
        --line: #2c3444;
        --bg: #0f1320;
        --card: #151b2b;
        --accent-2: #2b1f47;
        --shadow: 0 10px 28px rgba(0,0,0,.35);
      }
      img { filter: brightness(0.98) contrast(1.05); }
    }

    /* =====================================================
       BASE
       ===================================================== */
    html { scroll-behavior: smooth; }
    body {
      margin: 0;
      color: var(--ink);
      background: var(--bg);
      font: 16px/1.65 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .container {
      max-width: var(--maxw);
      margin: 0 auto;
      padding: 32px 20px 60px;
    }
    section { margin: 28px 0 40px; }

    /* =====================================================
       HEADINGS
       ===================================================== */
    .eyebrow {
      color: var(--muted);
      font-weight: 700;
      letter-spacing: .12em;
      text-transform: uppercase;
      font-size: .78rem;
    }
    h1, h2 { letter-spacing: .2px; margin: .35rem 0 .6rem; }
    h1 {
      font-size: clamp(1.8rem, 3vw, 2.2rem);
      line-height: 1.25;
      font-weight: 800;
    }
    h2 {
      font-size: clamp(1.25rem, 2.2vw, 1.5rem);
      font-weight: 800;
      display: flex;
      align-items: center;
      gap: .6rem;
    }
    h2::after {
      content: "";
      flex: 1 1 auto;
      height: 2px;
      background: linear-gradient(90deg, var(--accent), transparent);
      opacity: .4;
      border-radius: 999px;
    }

    p { margin: .6rem 0 1rem; }
    a { color: #0a58ca; text-decoration: none; }
    a:hover { text-decoration: underline; }

    /* =====================================================
       CARDS
       ===================================================== */
    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 22px 24px;
    }
    .card + .card { margin-top: 16px; }

    /* Highlight block for the opening narrative */
    .lead {
      border-left: 4px solid var(--accent);
      background: linear-gradient(0deg, rgba(111,66,193,.06), transparent 55%);
    }

    /* Figure styling */
    figure { margin: 18px 0; }
    figure img {
      width: 100%;
      height: auto;
      border-radius: 12px;
      border: 1px solid var(--line);
      box-shadow: 0 6px 16px rgba(0,0,0,.06);
    }
    figure figcaption { color: var(--muted); font-size: .92rem; margin-top: .4rem; }

    /* Callouts for links */
    .link-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }
    .btn-ghost {
      display: inline-flex;
      align-items: center;
      gap: .4rem;
      padding: .42rem .7rem;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: var(--card);
      box-shadow: 0 2px 8px rgba(0,0,0,.04);
      font-weight: 600;
      font-size: .92rem;
    }
    .btn-ghost:hover {
      text-decoration: none;
      border-color: #d8dfea;
    }

    /* Small helpers */
    .muted { color: var(--muted); }
  </style>

  <!-- MathJax (moved into head) -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async=""></script>


  <main class="container">

    <!-- =============================
         Research Interests
         ============================= -->
    <section id="research-interests" class="card lead">
      <div class="eyebrow">Research Interests</div>

      <p>
        I was born in 2000, just as sequencers were humming and computers were fast enough to keep up. I fell for math, statistics, and computer science early‚Äîtools that could turn biological complexity into testable questions. And yes, my last name is Ai; in a world obsessed with ‚ÄúAI,‚Äù it still introduces me before I do. I don't know if I have a silicon chip in my brain, but what hooked me wasn‚Äôt a gadget. It was a stubborn question: why do two people with the same disease and the same drug end up with wildly different outcomes? If we could answer that, medicine wouldn‚Äôt be one-size-fits-all‚Äîit would be personal.
      </p>
      <p>
        The digital revolution means we can actually try. We can read genomes, watch gene expression, map epigenetic shifts, and stitch these signals together with models that learn. That‚Äôs the work I love: translate noisy data into clear hypotheses, test them, and push the results toward decisions that help real patients.
      </p>
    </section>

    <!-- =============================
         eQTL Methods
         ============================= -->
    <section id="context-specific-eqtls" class="card">
      <div class="eyebrow">Statistical Genomics</div>
      <h2 class="anchored">Statistical Methods for Detecting Context-Specific eQTLs</h2>

      <p>
        I begin with the hypothesis that genetic variants exert regulatory effects on gene expression in a context-dependent manner‚Äîspecific to certain cell types, tissues, or environmental conditions‚Äîand that these context-specific eQTLs mediate genetic risk for complex diseases. Therefore, systematically identifying and characterizing such eQTLs can bridge the gap between regulatory genetic variation and functional consequences, refine our understanding of disease-relevant mechanisms, and ultimately support precision medicine tailored to individual genetic backgrounds and biological contexts.
      </p>
      <p>
        Genome-wide association studies (GWAS) have identified thousands of variants associated with complex traits and diseases, but most lie in non-coding regions, leaving their functional roles unclear. Expression quantitative trait loci (eQTL) mapping provides a critical link, uncovering how genetic variants regulate transcription. The advent of single-cell RNA-sequencing (scRNA-seq) has transformed this field by measuring genome-wide expression at the resolution of individual cells, in contrast to bulk RNA-seq, which averages expression across cell populations. scRNA-seq not only enables identification of cell subtypes and their marker genes but also reveals that cellular heterogeneity is far greater than previously appreciated. This motivates my research: to leverage scRNA-seq data to test the hypothesis that many eQTLs exhibit context-specific effects, influencing expression in one tissue, cell type, or condition but not in another.
      </p>
      <p>
        Working with
        <a href="https://brunildaballiu.github.io/" target="_blank" rel="noopener">Dr. Brunilda Balliu</a>,
        I refined <a href="https://www.biorxiv.org/content/10.1101/2021.06.17.448889v2" target="_blank" rel="noopener">FastGxC</a>, a statistical framework for efficient mapping of context-specific eQTLs. FastGxC operates in three principal steps: (1) Decomposition of gene expression into context-shared and context-specific components. (2) Regression of cis-acting single nucleotide polymorphisms (cis-SNPs) on these components. (3) Identification of significant eQTLs using hierarchical false discovery rate (FDR) control. I focused on refining the third step of multiple testing correction. I compared two hierarchical FDR control methods‚ÄîTreeQTL and TreeBH‚Äîagainst the empirical Bayes shrinkage framework in mashR, using simulations that varied in intra-individual correlation and sample size. Results showed that with larger sample sizes, hierarchical methods (especially TreeBH) achieved improved power and competitive performance relative to mashR. These findings highlight that sample size and correlation structure should guide the choice of correction strategy. The
        <a href="https://github.com/BalliuLab/FastGxC" target="_blank" rel="noopener">updated FastGxC pipeline</a> thus provides a flexible, computationally efficient, and statistically rigorous framework for detecting context-specific regulatory effects. By enabling more precise identification of genetic effects across tissues, cell types, and conditions, this approach advances both the methodological toolkit for eQTL mapping and the broader goal of understanding the genetic basis of human phenotypic diversity.
      </p>

      <div class="link-row" aria-label="Related Links">
        <a class="btn-ghost" href="https://www.biorxiv.org/content/10.1101/2021.06.17.448889v2.full.pdf" target="_blank" rel="noopener">üìÑ BioRxiv: FastGxC</a>
        <a class="btn-ghost" href="https://jacenai.github.io/Biostatistics/MS_report.pdf" target="_blank" rel="noopener">üìÑ Multiple Testing Correction Comparison</a>
        <a class="btn-ghost" href="https://github.com/BalliuLab/FastGxC" target="_blank" rel="noopener">üß™ GitHub: FastGxC</a>
      </div>

      <figure class="figure">
        <img src="img/FastGxC.png" alt="Overview diagram of the FastGxC pipeline for mapping context-specific eQTLs." class="figure-img">
        <figcaption class="muted">FastGxC overview.</figcaption>
      </figure>

      <p style="margin-top: 1.2rem;">
        Building on these, I have begun applying FastGxC to clinically relevant contexts, where cell-type‚Äìspecific eQTLs hold meaningful implications for the treatment of complex diseases. Crohn‚Äôs disease (CD), a chronic inflammatory bowel disorder with a complex genetic architecture, shows cell-type‚Äìspecific transcriptional perturbations in the ileum and colon during active disease. This suggests that cell-type specific eQTLs may play a role in CD pathogenesis. While the FastGxC framework provides a powerful tool, it currently relies on single-cell RNA-seq data, which are substantially more costly than bulk RNA-seq for large-scale studies, for detecting cell-type specific eQTLs. Motivated by the hypothesis that bulk RNA-seq contains sufficient information to infer cell-type specific eQTLs, I am working with
        <a href="https://www.cedars-sinai.edu/health-sciences-university/research/labs/casero-lab.html" target="_blank" rel="noopener">Dr. David Casero</a>
        on developing a pipeline to: (1) Impute cell-type proportions from bulk RNA-seq data of inflammatory bowel disease patients using scRNA-seq as a reference; (2) Estimate cell-type specific expression from bulk RNA-seq via a Bayesian deconvolution method; (3) Apply FastGxC to identify cell-type specific eQTLs. Ultimately, this work could help shift precision medicine from an aspiration to a reality, by showing that the genetic underpinnings of complex disease can be resolved at cell-type resolution using the same bulk RNA-seq data already collected in clinical practice.
      </p>

      <figure class="figure">
        <img src="img/IBD.png" alt="Overview diagram of the IBD research for mapping cell-type-specific eQTLs." class="figure-img">
        <figcaption class="muted">Graphical abstract.</figcaption>
      </figure>
    </section>

    <!-- =============================
         DNA Methylation / Epigenetics
         ============================= -->
    <section id="epigenetics-dnam" class="card">
      <div class="eyebrow">Epigenetics &amp; Statistical Genomics</div>
      <h2 class="anchored">DNA Methylation Dynamics and Epigenetic Regulation</h2>

      <p>
        Epigenetic variation provides insights into cellular states and developmental histories that static genotype information cannot: DNA methylation and related marks are dynamic, cell-type‚Äìspecific, and mitotically heritable, encoding both regulatory activity and environmental exposures. Furthermore, unlike the fixed genome sequence, these patterns are plastic, making the correction of aberrant, disease-causing epigenetic states a compelling therapeutic avenue.
      </p>

      <p>
        Building on the hypothesis that DNA methylation (DNAm) shapes gene regulation and thereby influences biological processes, I worked with
        <a href="https://medschool.ucla.edu/people/matteo-pellegrini-phd" target="_blank" rel="noopener">Dr. Matteo Pellegrini</a>
        to develop statistical models that extract informative DNAm features predictive of immune response to influenza vaccination and to probe the regulatory mechanisms by which DNAm modulates gene expression. Our approach unfolded in three steps: (1) identifying CpG sites significantly associated with vaccine response; (2) linking these response-associated CpGs to putative target genes which can also predict immune response; and (3) testing two mechanistic hypotheses: (a) cis-regulatory effects, where DNAm at regulatory elements directly modulates nearby immune-response genes, and (b) TF-mediated effects, where DNAm at transcription-factor binding motifs alters TF occupancy and downstream transcription. These findings highlight the potential of DNAm-based signatures to refine our understanding of vaccine responsiveness and support the development of next-generation influenza vaccines tailored to individual epigenetic profiles.
      </p>

      <figure class="figure">
        <img src="img/UGA6.png" alt="Overview diagram of the UGA6 research for mapping DNA methylation dynamics." class="figure-img">
        <figcaption class="muted">DNAm Regulation in UGA6 Cohort ‚Äî Methods Overview.</figcaption>
      </figure>

      <p>
        In DNAm models, age and immune measures are highly correlated and thus confound each other, leading to non-identifiable coefficients. This is a common issue in statistical modeling, particularly in high-dimensional settings where predictors can be highly correlated. If we simply include both in a regression model, the coefficients for each may not accurately reflect their individual contributions to DNAm variation. Inspired by Gram‚ÄìSchmidt process, I address this with a
        <a href="https://jacenai.github.io/Biostatistics/08.12.25.UGA6_Methylation.html#sequential-orthogonalization" target="_blank" rel="noopener"><em>sequential orthogonalization</em></a>
        of predictors: for each predictor \(X_j\), I remove what is explained by all earlier (already orthogonalized) predictors, \(X_j^{\perp}=X_j-\mathcal{P}_{\{X_1^{\perp},\ldots,X_{j-1}^{\perp}\}}(X_j)\). The transformed design \(X^{\perp}=(X_1^{\perp},\ldots,X_p^{\perp})\) has mutually orthogonal columns, so coefficients are identifiable and each \(\beta_j\) captures the unique contribution of \(X_j\) (e.g., immune response) after accounting for confounders (e.g., age). In practice this yields stable fits, clearer effect estimates, and coefficients whose interpretation depends on a biologically motivated ordering, with demographic factors entered first to ensure immune-response variables are properly adjusted.
      </p>

      <div class="link-row" aria-label="Related Links">
        <a class="btn-ghost" href="https://jacenai.github.io/Biostatistics/08.12.25.UGA6_Methylation.html#sequential-orthogonalization" target="_blank" rel="noopener">üìÑ Sequential Orthogonalization</a>
      </div>
    </section>

  </main>





</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>